import re
import json
import random
import string
import asyncio
from typing import Any, Dict, List, Optional
from pydantic import BaseModel

# --- Data Structures ---

class WorkflowNode(BaseModel):
    id: str
    type: str  # e.g., 'start', 'trigger', 'action_send_email', 'tool_random_string'
    label: str
    config: Dict[str, Any] = {}
    next_node_id: Optional[str] = None

class WorkflowDefinition(BaseModel):
    id: str
    name: str
    nodes: Dict[str, WorkflowNode]  # Key is node_id
    start_node_id: str

# --- Runtime Context ---

class WorkflowContext:
    """
    Holds the state of a running workflow.
    Everything that happens is stored here.
    """
    def __init__(self, trigger_data: Dict[str, Any]):
        self.data: Dict[str, Any] = {
            "trigger": trigger_data,  # Constant data from the event
            "steps": {},              # Dynamic data generated by nodes
            "global": {},             # System global variables
        }

    def set_step_output(self, node_id: str, output: Any):
        """Save the result of a node execution."""
        self.data["steps"][node_id] = output

    def get_value(self, path: str) -> Any:
        """
        Retrieve a value using dot notation.
        e.g., "trigger.user.email" -> self.data["trigger"]["user"]["email"]
        """
        parts = path.split('.')
        current = self.data
        
        try:
            for part in parts:
                if isinstance(current, dict) and part in current:
                    current = current[part]
                else:
                    return None  # Path not found
            return current
        except Exception:
            return None

# --- Variable Resolver ---

class VariableResolver:
    """
    The magic class that converts "{{variable}}" into real values.
    """
    
    @staticmethod
    def resolve(template: Any, context: WorkflowContext) -> Any:
        """
        Recursively resolves variables in dictionaries, lists, and strings.
        """
        # Case 1: Dict -> Recursively resolve values
        if isinstance(template, dict):
            return {k: VariableResolver.resolve(v, context) for k, v in template.items()}
        
        # Case 2: List -> Recursively resolve items
        if isinstance(template, list):
            return [VariableResolver.resolve(item, context) for item in template]
        
        # Case 3: String -> Check for {{...}} patterns
        if isinstance(template, str):
            # Pattern 1: Exact Match (e.g. "{{trigger.count}}") -> Return actual type (int/obj/etc)
            strict_pattern = r'^\{\{([\w\.]+)\}\}$'
            match = re.match(strict_pattern, template.strip())
            if match:
                path = match.group(1)
                val = context.get_value(path)
                # If value is found, return it (preserving type); otherwise return original string
                return val if val is not None else template 
            
            # Pattern 2: Interpolation (e.g. "Hello {{trigger.name}}") -> Return string
            def replace_func(m):
                path = m.group(1)
                val = context.get_value(path)
                return str(val) if val is not None else m.group(0)
            
            if '{{' in template:
                return re.sub(r'\{\{([\w\.]+)\}\}', replace_func, template)

        # Case 4: Primitives -> Return as is
        return template

# --- The Engine ---

class WorkflowEngine:
    def __init__(self, workflow: WorkflowDefinition, handlers: Dict[str, Any] = None):
        self.workflow = workflow
        # 允许外部注入 handlers，实现逻辑解耦
        self.handlers = handlers or {}

    async def run(self, trigger_data: Dict[str, Any]):
        """
        The main execution loop.
        """
        context = WorkflowContext(trigger_data)
        current_node_id = self.workflow.start_node_id
        
        print(f"\n[ENGINE] Starting Workflow: {self.workflow.name}")
        print(f"[ENGINE] Trigger Data: {json.dumps(trigger_data, default=str)}")
        
        while current_node_id:
            node = self.workflow.nodes.get(current_node_id)
            if not node:
                print(f"[ENGINE] Error: Next node {current_node_id} not found. Stopping.")
                break
                
            print(f"\n>> Executing Node: [{node.label}] ({node.type})")
            
            # 1. Resolve Config: Turn {{variables}} into real values
            resolved_config = VariableResolver.resolve(node.config, context)
            # print(f"   Config (Resolved): {json.dumps(resolved_config, ensure_ascii=False)}")
            
            # 2. Execute Logic: Call the specific handler
            output = await self.execute_node(node.type, resolved_config, context)
            
            # 3. Save Output: Store result in context
            context.set_step_output(node.id, output)
            print(f"   Output Saved to 'steps.{node.id}': {output}")
            
            # 4. Move to Next
            current_node_id = node.next_node_id
            
        print("\n[ENGINE] Workflow Finished Successfully.")
        return context

    async def execute_node(self, node_type: str, config: Dict[str, Any], context: WorkflowContext):
        """
        Executes a node by calling a registered handler.
        This keeps the engine pure and decouples it from specific business logic.
        """
        if node_type == 'start':
            return {"status": "started"}
            
        handler = self.handlers.get(node_type)
        if not handler:
            print(f"[ENGINE] Warning: No handler registered for node type '{node_type}'")
            return None
            
        try:
            # Handle both async and sync handlers
            if asyncio.iscoroutinefunction(handler):
                return await handler(config, context)
            else:
                return handler(config, context)
        except Exception as e:
            print(f"[ENGINE] Error executing node {node_type}: {str(e)}")
            # In production, we might want to throw or stop the workflow here
            raise e