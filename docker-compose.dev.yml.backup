# "services" 是最核心的部分，用来定义我们项目需要的各个独立服务（容器）
services:
  # --- 后端服务 (FastAPI 应用) ---
  backend:
    # 'build' 指令告诉 Docker Compose 如何构建这个服务的镜像
    build:
      # 'context' 指定了 Dockerfile 所在的目录
      context: ./backend
      # 'dockerfile' 指定了用于构建镜像的文件名
      dockerfile: Dockerfile
    # 'ports' 将容器的端口映射到主机的端口
    # 格式是 "主机端口:容器端口"
    ports:
      - "8000:8000"  # FastAPI HTTP API
      - "24:24"      # LMTP 邮件接收服务
    # 'volumes' 将主机的文件或目录挂载到容器中
    # 格式是 "主机路径:容器路径"
    # 这对于开发非常重要，因为我们在主机上修改代码后，会立刻同步到容器里，无需重新构建镜像
    volumes:
      - ./backend:/app
      - ./config.json:/app/config.json
      - ./scripts:/scripts
      # 挂载 docker socket，让 backend 可以执行 docker 命令来同步用户到邮件服务器
      - /var/run/docker.sock:/var/run/docker.sock
    # 'env_file' 指定了用于加载环境变量的文件
    # 我们的 FastAPI 应用会从这个 .env 文件中读取数据库连接信息、管理员密码等配置
    env_file:
      - .env
    # 'depends_on' 定义了服务之间的依赖关系
    # 这确保了在启动 backend 服务之前，db 和 mailserver 服务会先被启动
    depends_on:
      db:
        condition: service_healthy  # 等待数据库健康检查通过
      mailserver:
        condition: service_started
    # 直接启动 uvicorn，数据库就绪由 healthcheck 保证
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload

  # --- 前端服务 (Nuxt.js 应用) ---
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      # 将主机的 3000 端口映射到容器的 3000 端口
      - "3000:3000"
    volumes:
      # 将前端代码目录挂载到容器中，实现代码热更新
      - ./frontend:/app
      # 这是一个匿名卷，用来防止主机上的 node_modules 覆盖容器内的 node_modules
      # 这是一个常见的优化技巧，可以避免因操作系统不同导致的依赖问题
      - /app/node_modules
    # 从 .env.caddy 加载 WEB_DOMAIN 环境变量 (与 Caddy 保持一致)
    env_file:
      - .env.caddy
    # 启动 Nuxt.js 的开发服务器，监听所有网络接口以便 Caddy 可以访问
    command: npm run dev -- --host 0.0.0.0

  # --- 数据库服务 (PostgreSQL) ---
  db:
    # 'image' 指定了要使用的 Docker 镜像
    # 这里我们直接使用官方的 postgres 15 镜像，而不需要自己构建
    image: postgres:15
    # 从 .env 文件加载数据库的用户名、密码和数据库名
    env_file:
      - .env
    # 'volumes' 用于数据持久化
    # 我们将一个名为 'postgres_data' 的具名卷挂载到容器存放数据的目录
    # 这样即使容器被删除，我们的数据库数据也能被保留下来
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      # 将主机的 5432 端口映射到容器的 5432 端口，方便我们用数据库工具直连
      - "5432:5432"
    # 健康检查：使用 PostgreSQL 自带的 pg_isready 命令
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 10
      start_period: 10s

  # --- 邮件服务器 (docker-mailserver) ---
  mailserver:
    build:
      context: ./config/mail
      dockerfile: Dockerfile
    container_name: talentmail-mailserver-1
    hostname: ${MAIL_HOSTNAME:-maillink.talenting.test}
    env_file: ./config/mail/development/mailserver.env
    environment:
      - PERMIT_DOCKER=network
    ports:
      - "25:25"    # SMTP
      - "143:143"  # IMAP
      - "587:587"  # SMTP (submission)
      - "993:993"  # IMAPS
    volumes:
      - ./data/mailserver/mail-data/:/var/mail/
      - ./data/mailserver/mail-state/:/var/mail-state/
      - ./data/mailserver/mail-logs/:/var/log/mail/
      - ./data/mailserver/config/:/tmp/docker-mailserver/
      - /etc/localtime:/etc/localtime:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      # Dovecot SQL 认证配置 - 让邮件服务器直接使用我们的数据库认证
      - ./config/mail/dovecot-sql.conf.ext:/etc/dovecot/dovecot-sql.conf.ext:ro
      - ./config/mail/dovecot/10-auth.conf:/etc/dovecot/conf.d/10-auth.conf:ro
      # Fail2Ban 白名单配置
      - ./config/mail/fail2ban-jail.local:/etc/fail2ban/jail.local:ro
      # 注意：user-patches.sh 需要放在 data/mailserver/config/ 目录中
      # 因为 /tmp/docker-mailserver/ 已经被整个目录挂载覆盖
    # 邮件服务器依赖数据库（用于 SQL 认证）
    depends_on:
      db:
        condition: service_healthy
    restart: always
    stop_grace_period: 1m
    cap_add:
      - NET_ADMIN

  # --- Caddy 网关服务 (开发环境) ---
  # 让我们能通过 https://mail.talenting.test 访问应用
  caddy:
    image: caddy:alpine
    restart: always
    ports:
      # 开发环境只使用 HTTP，不需要 HTTPS
      - "80:80"
      # 443 端口已注释，因为开发环境使用纯 HTTP 模式
      # - "443:443"
    volumes:
      # 挂载 Caddy 配置文件
      - ./config/caddy/Caddyfile:/etc/caddy/Caddyfile
      # 使用具名卷来持久化 Caddy 自动生成的 TLS 证书
      - caddy_data:/data
    # 从 .env.caddy 文件加载 WEB_DOMAIN 环境变量
    env_file:
      - .env.caddy
    # 确保 Caddy 在它需要代理的服务启动之后再启动
    depends_on:
      - backend
      - frontend
 
# 'volumes' 用来统一定义在上面服务中使用的具名卷
volumes:
  # 定义一个名为 'postgres_data' 的卷，用于持久化数据库数据
  postgres_data:
  # 为 Caddy 定义一个数据卷，用于存储证书等
  caddy_data:
